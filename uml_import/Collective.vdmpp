class Collective
values
	private minSmall = 7;
	private minBig = 8;
instance variables
  clients: set of Client := {};
  farmers: set of Farmer := {};
  waiting: set of Client := {};
  baskets: set of Basket := {};
  location: Utils`string;
  smallBaskets: nat := 0;
  maxSmallBaskets: real := 0;
  inv smallBaskets <= maxSmallBaskets and maxSmallBaskets >= 0;
  bigBaskets: nat := 0;
  maxBigBaskets: real := 0;
  inv bigBaskets <= maxBigBaskets and maxBigBaskets >= 0;
  prodAvailability: Utils`ProdGrams; -- indica a disponibilidade de producao em gramas de cada produto

operations

	public Collective: Utils`string ==> Collective
		Collective(loc) == (
			location:= loc;
			prodAvailability := {|->};
			return self;
		)
		pre len loc > 0
		post location = loc and prodAvailability = {|->}; -- TODO ver se é preciso verificar os outros

  public addAssociate : seq of (char) ==> bool
  addAssociate(cli) ==
    is not yet specified;

  public removeAssociate : Client ==> ()
  removeAssociate(cli) ==
    is not yet specified;

  public addFarmer : Farmer ==> ()
  	addFarmer(farmer) == (
  		farmers := farmers union {farmer};
  		for all prod in set dom farmer.production do (
  			if prod not in set dom prodAvailability
  			then prodAvailability := prodAvailability ++ {prod |-> farmer.production(prod)}
  			else prodAvailability := prodAvailability ++ {prod |-> farmer.production(prod)+prodAvailability(prod)}
  		);
  	)
  	pre farmer not in set farmers
  	post farmer in set farmers and farmers = farmers~ union {farmer}
  		and forall prod in set dom farmer.production & prod in set dom prodAvailability and
  		if prod not in set dom prodAvailability~
  		then prodAvailability(prod) = farmer.production(prod)
  		else prodAvailability(prod) = farmer.production(prod)+prodAvailability~(prod);

  public removeFarmer : Farmer ==> ()
  	removeFarmer(farmer) == ( 
  		farmers := farmers \ {farmer};
  		for all prod in set dom farmer.production do(
  			if prodAvailability(prod) = farmer.production(prod)
  			then prodAvailability := {prod} <-: prodAvailability
  			else prodAvailability := prodAvailability ++ {prod |-> prodAvailability(prod) - farmer.production(prod)};
  		);
  	)
  	pre farmer in set farmers
  	post farmer not in set farmers and farmers = farmers~ \ {farmer}
  		and forall prod in set dom farmer.production & if prodAvailability~(prod) = farmer.production(prod)
  		then prod not in set dom prodAvailability
  		else prodAvailability(prod) = prodAvailability~(prod) - farmer.production(prod);

	public updateMaxBaskets: () ==> ()
		updateMaxBaskets() == (
			dcl numberProds: nat := card dom prodAvailability;
			dcl sum: real := 0;
			for all prod in set dom prodAvailability do (
				sum := sum + prodAvailability(prod)
			);
			if numberProds >= minSmall and sum >= Utils`smallWeight
			then maxSmallBaskets := sum / Utils`smallWeight
			else maxSmallBaskets := 0;
			if numberProds >= minBig and sum >= Utils`bigWeight
			then maxBigBaskets := sum / Utils`bigWeight
			else maxBigBaskets := 0;
		)
		pre prodAvailability <> {|->}
		post maxSmallBaskets >= 0 and maxBigBaskets >= 0 and maxSmallBaskets >= 2 * maxBigBaskets;

  public  updateRequests : ()  ==> ?
  updateRequests() ==
    is not yet specified;


end Collective
