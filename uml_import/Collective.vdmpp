class Collective
values
	private minSmall = 7;
	private minBig = 8;
instance variables
  clients: set of Client := {};
  farmers: set of Farmer := {};
  waiting: set of Client := {};
  baskets: set of Basket := {};
  inv forall cli in set clients & cli not in set waiting;
  location: Utils`string;
  smallBaskets: nat := 0;
  maxSmallBaskets: real := 0;
  inv smallBaskets <= maxSmallBaskets and maxSmallBaskets >= 0;
  bigBaskets: nat := 0;
  maxBigBaskets: real := 0;
  inv bigBaskets <= maxBigBaskets and maxBigBaskets >= 0;
  prodAvailability: Utils`ProdGrams; -- indica a disponibilidade de producao em gramas de cada produto

operations

	public Collective: Utils`string ==> Collective
		Collective(loc) == (
			location:= loc;
			prodAvailability := {|->};
			return self;
		)
		pre len loc > 0
		post location = loc and prodAvailability = {|->}; -- TODO ver se é preciso verificar os outros

  public addAssociate : Client ==> bool
  	addAssociate(cli) == (
  		if cli.basketRequest = <Small> and smallBaskets + 1 <= maxSmallBaskets
  		then (
  			smallBaskets := smallBaskets + 1;
  			clients := clients union {cli};
  			return true
  		);
  		if cli.basketRequest = <Big> and bigBaskets + 1 <= maxBigBaskets
  		then (
  			bigBaskets := bigBaskets + 1;
  			clients := clients union {cli};
  			return true
  		);
  		waiting := waiting union {cli};
  		return false
  	)
  	pre cli not in set clients and cli not in set waiting
  	post (cli in set clients or cli in set waiting) and
  		if cli in set clients then (smallBaskets = smallBaskets~ + 1 or bigBaskets = bigBaskets~ + 1)
  		else (smallBaskets = smallBaskets~ and bigBaskets = bigBaskets~ and cli in set waiting);

  public removeAssociate : Client ==> ()
  	removeAssociate(cli) == (
  		if cli in set waiting
  		then (
  			waiting := waiting \ {cli};
  			return
  		)
  		else clients := clients \ {cli};
  		if cli.basketRequest = <Small>
  		then smallBaskets := smallBaskets - 1
  		else bigBaskets := bigBaskets -1;
  	)
    pre cli in set clients or cli in set waiting
    post cli not in set clients and cli not in set waiting and
    	if cli in set clients~ and cli.basketRequest = <Small> then smallBaskets = smallBaskets~ - 1
    	else if cli in set clients~ and cli.basketRequest = <Big> then bigBaskets = bigBaskets~ - 1
    	else smallBaskets = smallBaskets~ and bigBaskets = bigBaskets~;

  public addFarmer : Farmer ==> ()
  	addFarmer(farmer) == (
  		farmers := farmers union {farmer};
  		for all prod in set dom farmer.production do (
  			if prod not in set dom prodAvailability
  			then prodAvailability := prodAvailability ++ {prod |-> farmer.production(prod)}
  			else prodAvailability := prodAvailability ++ {prod |-> farmer.production(prod)+prodAvailability(prod)}
  		);
  	)
  	pre farmer not in set farmers
  	post farmer in set farmers and farmers = farmers~ union {farmer}
  		and forall prod in set dom farmer.production & prod in set dom prodAvailability and
  		if prod not in set dom prodAvailability~
  		then prodAvailability(prod) = farmer.production(prod)
  		else prodAvailability(prod) = farmer.production(prod)+prodAvailability~(prod);

  public removeFarmer : Farmer ==> ()
  	removeFarmer(farmer) == ( 
  		farmers := farmers \ {farmer};
  		for all prod in set dom farmer.production do(
  			if prodAvailability(prod) = farmer.production(prod)
  			then prodAvailability := {prod} <-: prodAvailability
  			else prodAvailability := prodAvailability ++ {prod |-> prodAvailability(prod) - farmer.production(prod)};
  		);
  	)
  	pre farmer in set farmers
  	post farmer not in set farmers and farmers = farmers~ \ {farmer}
  		and forall prod in set dom farmer.production & if prodAvailability~(prod) = farmer.production(prod)
  		then prod not in set dom prodAvailability
  		else prodAvailability(prod) = prodAvailability~(prod) - farmer.production(prod);

	public updateMaxBaskets: () ==> ()
		updateMaxBaskets() == (
			dcl numberProds: nat := card dom prodAvailability;
			dcl sum: real := 0;
			for all prod in set dom prodAvailability do (
				sum := sum + prodAvailability(prod)
			);
			if numberProds >= minSmall and sum >= Utils`smallWeight
			then maxSmallBaskets := sum / Utils`smallWeight
			else maxSmallBaskets := 0;
			if numberProds >= minBig and sum >= Utils`bigWeight
			then maxBigBaskets := sum / Utils`bigWeight
			else maxBigBaskets := 0;
		)
		pre prodAvailability <> {|->}
		post maxSmallBaskets >= 0 and maxBigBaskets >= 0 and maxSmallBaskets >= 2 * maxBigBaskets;

  public  updateRequests : ()  ==> ?
  updateRequests() ==
    is not yet specified;


end Collective
