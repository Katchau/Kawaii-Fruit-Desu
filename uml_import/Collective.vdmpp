class Collective
values
	private minSmall = 7;
	private minBig = 8;
instance variables
  public clients: set of Client := {};
  public farmers: set of Farmer := {};
  public waiting: Stack := new Stack();
  public baskets: set of Basket := {};
  inv forall cli in set clients & cli not in set elems waiting.contents;
  public location: Utils`string;
  public smallBaskets: nat := 0;
  public maxSmallBaskets: real := 0;
  inv smallBaskets <= maxSmallBaskets and maxSmallBaskets >= 0;
  public bigBaskets: nat := 0;
  public maxBigBaskets: real := 0;
  inv bigBaskets <= maxBigBaskets and maxBigBaskets >= 0;
  public prodAvailability: Utils`ProdGrams; -- indica a disponibilidade de producao em gramas de cada produto

operations

	public Collective: Utils`string ==> Collective
		Collective(loc) == (
			location:= loc;
			prodAvailability := {|->};
			return self;
		)
		pre len loc > 0
		post location = loc and prodAvailability = {|->}; -- TODO ver se é preciso verificar os outros

  public addAssociate : Client ==> bool
  	addAssociate(cli) == (
  		if cli.basketRequest = <Small> and smallBaskets + 1 <= maxSmallBaskets
  		then (
  			smallBaskets := smallBaskets + 1;
  			clients := clients union {cli};
  			return true
  		);
  		if cli.basketRequest = <Big> and bigBaskets + 1 <= maxBigBaskets
  		then (
  			bigBaskets := bigBaskets + 1;
  			clients := clients union {cli};
  			return true
  		);
  		waiting.push(cli);
  		return false
  	)
  	pre cli not in set clients and cli not in set elems waiting.contents
  	post (cli in set clients or cli in set elems waiting.contents) and
  		if cli in set clients then (smallBaskets = smallBaskets~ + 1 or bigBaskets = bigBaskets~ + 1)
  		else (smallBaskets = smallBaskets~ and bigBaskets = bigBaskets~ and cli in set elems waiting.contents);

  public removeAssociate : Client ==> ()
  	removeAssociate(cli) == (
  		clients := clients \ {cli};
  		if cli.basketRequest = <Small>
  		then smallBaskets := smallBaskets - 1
  		else bigBaskets := bigBaskets -1;
  	)
    pre cli in set clients and cli not in set elems waiting.contents
    post cli not in set clients and
    	if cli in set clients~ and cli.basketRequest = <Small> then smallBaskets = smallBaskets~ - 1
    	else if cli in set clients~ and cli.basketRequest = <Big> then bigBaskets = bigBaskets~ - 1
    	else smallBaskets = smallBaskets~ and bigBaskets = bigBaskets~;
	
	public hasFreeSpace : Utils`BasketType ==> bool
		hasFreeSpace(basketType) == (
			if basketType = <Small>
			then return smallBaskets + 1 <= maxSmallBaskets
			else return bigBaskets + 1 <= maxBigBaskets
		)
		post if basketType = <Small>
			then RESULT = smallBaskets + 1 <= maxSmallBaskets
			else RESULT = bigBaskets + 1 <= maxBigBaskets;
	
	public updateWaitingList: () ==> bool
		updateWaitingList() == (
			dcl nextCli: Client := waiting.top();
			if hasFreeSpace(nextCli.basketRequest)
			then ( 
				waiting.pop();
				return addAssociate(nextCli)
			)
			else return false;
		)
		pre clients <> {} and waiting.contents <> [];
	
  public addFarmer : Farmer ==> ()
  	addFarmer(farmer) == (
  		farmers := farmers union {farmer};
  		for all prod in set dom farmer.production do (
  			if prod not in set dom prodAvailability
  			then prodAvailability := prodAvailability ++ {prod |-> farmer.production(prod)}
  			else prodAvailability := prodAvailability ++ {prod |-> farmer.production(prod)+prodAvailability(prod)}
  		);
  	)
  	pre farmer not in set farmers
  	post farmer in set farmers and farmers = farmers~ union {farmer}
  		and forall prod in set dom farmer.production & prod in set dom prodAvailability and
  		if prod not in set dom prodAvailability~
  		then prodAvailability(prod) = farmer.production(prod)
  		else prodAvailability(prod) = farmer.production(prod)+prodAvailability~(prod);

  public removeFarmer : Farmer ==> ()
  	removeFarmer(farmer) == ( 
  		farmers := farmers \ {farmer};
  		for all prod in set dom farmer.production do(
  			if prodAvailability(prod) = farmer.production(prod)
  			then prodAvailability := {prod} <-: prodAvailability
  			else prodAvailability := prodAvailability ++ {prod |-> prodAvailability(prod) - farmer.production(prod)};
  		);
  	)
  	pre farmer in set farmers
  	post farmer not in set farmers and farmers = farmers~ \ {farmer}
  		and forall prod in set dom farmer.production & if prodAvailability~(prod) = farmer.production(prod)
  		then prod not in set dom prodAvailability
  		else prodAvailability(prod) = prodAvailability~(prod) - farmer.production(prod);

	public updateMaxBaskets: () ==> ()
		updateMaxBaskets() == (
			dcl numberProds: nat := card dom prodAvailability;
			dcl sum: real := 0;
			for all prod in set dom prodAvailability do (
				sum := sum + prodAvailability(prod)
			);
			if numberProds >= minSmall and sum >= Utils`smallWeight
			then maxSmallBaskets := sum / Utils`smallWeight
			else maxSmallBaskets := 0;
			if numberProds >= minBig and sum >= Utils`bigWeight
			then maxBigBaskets := sum / Utils`bigWeight
			else maxBigBaskets := 0;
		)
		pre prodAvailability <> {|->}
		post maxSmallBaskets >= 0 and maxBigBaskets >= 0 and maxSmallBaskets >= 2 * maxBigBaskets;

  public  updateRequests : ()  ==> ?
  updateRequests() ==
    is not yet specified;


end Collective
