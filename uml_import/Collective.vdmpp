class Collective
values
	private basketSmall = 7;
	private basketBig = 8;
	private minSmall = Utils`smallWeight / basketSmall;
	private minBig = Utils`bigWeight / basketBig;
instance variables
  public clients: set of Client := {};
  public farmers: set of Farmer := {};
  public waiting: Stack := new Stack();
  public baskets: set of Basket := {};
  inv forall cli in set clients & cli not in set elems waiting.contents;
  public location: Utils`string;
  public smallBaskets: nat := 0;
  public bigBaskets: nat := 0;
  inv bigBaskets + smallBaskets = card clients;
  public prodAvailability: Utils`ProdGrams; -- indica a disponibilidade de producao em gramas de cada produto
  
functions

	public isProdAvailable: nat * nat * real -> bool
		isProdAvailable(small,big,avail) == small * minSmall + big * minBig <= avail;
		
	public subtractMaps: Utils`ProdGrams * Utils`ProdGrams -> Utils`ProdGrams
		subtractMaps(p1, p2) == if p1 = {|->} or dom p1 inter dom p2 = {} then {|->}
			else let v in set (dom p1 inter dom p2) in ( p1 ++ {v |-> p1(v) - p2(v)}) ++ subtractMaps({v} <-: p1, {v} <-: p2)
		pre forall v in set dom p1 &
			if v in set dom p2 then p1(v) >= p2(v) else true;
		
operations

	public Collective: Utils`string ==> Collective
		Collective(loc) == (
			location:= loc;
			prodAvailability := {|->};
			return self;
		)
		pre len loc > 0
		post location = loc and prodAvailability = {|->}; -- TODO ver se é preciso verificar os outros
	
	public getClient: Utils`string ==> Client
		getClient(cname) == (
			dcl cli: Client;
			for all c in set clients do if Utils`stringsEquals(c.name, cname) then cli:= c;
			return cli;
		)
		pre exists1 cli in set clients & cli.name = cname
		post RESULT.name = cname and RESULT in set clients;
	
	public generateBasket: Utils`BasketType * Utils`ProdGrams ==> Basket
		generateBasket(basketType, curProds) == (
			dcl n: nat1;
			dcl minSize: real;
			dcl ret: Basket := new Basket({|->}, basketType);
			dcl stopCycle: bool;
			if basketType = <Small>
			then (
				n := basketSmall;
				minSize := minSmall
			)
			else (
				n := basketBig;
				minSize := minBig
			);
			for all prod in set dom curProds do(
				if curProds(prod) >= minSize and prod not in set dom ret.content and card dom ret.content < n
				then ret.add(prod, minSize)
				else if curProds(prod) < minSize and prod not in set dom ret.content and card dom ret.content < n
				then (
					stopCycle := false;
					for all p in set dom curProds do(
						if (curProds(p) - minSize) < (minSize - curProds(prod)) or stopCycle
						then skip
						else if p in set dom ret.content and ( curProds(p) - ret.getQuantity(p) ) >= (minSize - curProds(prod)) 
						then (
							ret.updateProductQuantity(p, (minSize - curProds(prod)));
							ret.add(prod, curProds(prod));
							stopCycle := true;
						)
						else if p not in set dom ret.content 
						then (
							ret.add(p, (minSize - curProds(prod)));
							ret.add(prod, curProds(prod));
							stopCycle := true
						);
					)
				);
			);
			return ret
		)
		pre curProds <> {|->} and if basketType = <Small>
			then Basket`getTotalWeight(curProds) + 2 >= Utils`smallWeight
			else Basket`getTotalWeight(curProds) + 2 >= Utils`bigWeight;
	
	public pure canAddAssociate : nat * nat * nat1 ==> bool
		canAddAssociate(small, big, minNumber) == (
			dcl sum: nat := 0;
			for all prod in set dom prodAvailability do (
				if isProdAvailable(small,big,prodAvailability(prod)) then sum := sum + 1;
			);
			return sum >= minNumber
		)
		pre small + big > 0;
	
  public addAssociate : Client ==> bool
  	addAssociate(cli) == (
  	IO`println(cli.basketRequest);
  		if cli.basketRequest = <Small> and canAddAssociate(smallBaskets +1, bigBaskets, basketSmall)
  		then (
  			atomic(
  				clients := clients union {cli};
  				smallBaskets := smallBaskets + 1
  			);
  			return true
  		);
  		if cli.basketRequest = <Big> and canAddAssociate(smallBaskets, bigBaskets + 1, basketBig)
  		then (
  			atomic(
  				clients := clients union {cli};
  				bigBaskets := bigBaskets + 1;
  			);
  			return true
  		);
  		waiting.push(cli);
  		IO`println("pushed");
  		return false
  	)
  	pre cli not in set clients 
  	and cli not in set elems waiting.contents
  	post (if RESULT then cli in set clients else cli in set elems waiting.contents) and
  		if cli in set clients then (smallBaskets = smallBaskets~ + 1 or bigBaskets = bigBaskets~ + 1)
  		else (smallBaskets = smallBaskets~ and bigBaskets = bigBaskets~ and cli in set elems waiting.contents);

  public removeAssociate : Client ==> ()
  	removeAssociate(cli) == (
  		if cli.basketRequest = <Small>
  		then atomic(
  				clients := clients \ {cli};
  				smallBaskets := smallBaskets - 1
  			)
  		else atomic(
  			clients := clients \ {cli};
  			bigBaskets := bigBaskets -1
  		);
  	)
    pre cli in set clients and cli not in set elems waiting.contents
    post cli not in set clients and
    	if cli in set clients~ and cli.basketRequest = <Small> then smallBaskets = smallBaskets~ - 1
    	else if cli in set clients~ and cli.basketRequest = <Big> then bigBaskets = bigBaskets~ - 1
    	else true;
	
	public addFromWaitingList: () ==> bool
		addFromWaitingList() == (
			dcl nextCli: Client := waiting.top();
			dcl hasFreeSpace: bool := false;
			
			if nextCli.basketRequest = <Small>
			then hasFreeSpace := canAddAssociate(smallBaskets +1, bigBaskets, basketSmall)
			else hasFreeSpace := canAddAssociate(smallBaskets, bigBaskets + 1, basketBig);
			
			if hasFreeSpace
			then ( 
				waiting.pop();
				return addAssociate(nextCli)
			)
			else return false;
		)
		pre waiting.contents <> []
		post if RESULT 
			then (waiting.contents = tl waiting~.contents and hd waiting~.contents in set clients )
			else ( waiting.contents = waiting~.contents and clients~ = clients );
	
	-- remover clientes em excesso
	public kickClients: () ==> ()
		kickClients() == (
			dcl size: nat1 := 1;
			for all cli in set clients do (
				if cli.basketRequest = <Small>
				then size := basketSmall
				else size := basketBig;
				if not canAddAssociate(smallBaskets, bigBaskets, size)
				then (
					removeAssociate(cli);
					waiting.push(cli)
				)
			)
		)
		pre card clients > 0
		post forall cli in set clients &
			if cli in set elems waiting.contents and cli in set clients~
			then if cli.basketRequest = <Small>
				then not canAddAssociate(smallBaskets + 1, bigBaskets, basketSmall)
				else not canAddAssociate(smallBaskets, bigBaskets +1, basketBig)
			else true;
	
	public getFarmer: Utils`string ==> Farmer
		getFarmer(fname) == (
			dcl farmer: Farmer;
			for all f in set farmers do if Utils`stringsEquals(f.name, fname) then farmer:= f;
			return farmer;
		)
		pre exists1 farmer in set farmers & farmer.name = fname
		post RESULT.name = fname and RESULT in set farmers;
	
  public addFarmer : Farmer ==> ()
  	addFarmer(farmer) == (
  		farmers := farmers union {farmer};
  		for all prod in set dom farmer.production do (
  			if prod not in set dom prodAvailability
  			then prodAvailability := prodAvailability ++ {prod |-> farmer.production(prod)}
  			else prodAvailability := prodAvailability ++ {prod |-> farmer.production(prod)+prodAvailability(prod)}
  		);
  	)
  	pre farmer not in set farmers
  	post farmer in set farmers and farmers = farmers~ union {farmer}
  		and forall prod in set dom farmer.production & prod in set dom prodAvailability and
  		if prod not in set dom prodAvailability~
  		then prodAvailability(prod) = farmer.production(prod)
  		else prodAvailability(prod) = farmer.production(prod)+prodAvailability~(prod);

  public removeFarmer : Farmer ==> ()
  	removeFarmer(farmer) == ( 
  		farmers := farmers \ {farmer};
  		for all prod in set dom farmer.production do(
  			if prodAvailability(prod) = farmer.production(prod)
  			then prodAvailability := {prod} <-: prodAvailability
  			else prodAvailability := prodAvailability ++ {prod |-> prodAvailability(prod) - farmer.production(prod)};
  		);
  	)
  	pre farmer in set farmers
  	post farmer not in set farmers and farmers = farmers~ \ {farmer}
  		and forall prod in set dom farmer.production & if prodAvailability~(prod) = farmer.production(prod)
  		then prod not in set dom prodAvailability
  		else prodAvailability(prod) = prodAvailability~(prod) - farmer.production(prod);

  public  updateRequests : ()  ==> ?
  updateRequests() ==
    is not yet specified;

	public collectBasket : Client ==> Basket 
  collectBasket(cl) == ( 
    if cl.hasCancelled then return undefined; 
    if cl.hasCollected then return undefined; 
    if cl.basketRequest = <Small> then smallBaskets := smallBaskets - 1; 
    if cl.basketRequest = <Big> then bigBaskets := bigBaskets - 1;  
    cl.setHasCollected(true); 
    return generateBasket(cl.basketRequest) 
  ) 
  pre cl in set clients 
  post if cl.hasCancelled then (RESULT = undefined) else (1=1) and 
    if cl.hasCollected then (RESULT = undefined) else (1=1) and 
    if cl.basketRequest = <Small> then smallBaskets = smallBaskets~ - 1 else bigBaskets = bigBaskets~ - 1 and 
    cl.hasCollected = true; 
 
 
  public generateBasket : Utils`BasketType ==> Basket 
  generateBasket(s) == is not yet specified; 
   
end Collective
